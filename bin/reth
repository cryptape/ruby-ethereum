#!/usr/bin/env ruby

$:.unshift File.expand_path('../../lib', __FILE__)

require 'ethereum/app/full'

#Ethereum::Logger.level = :debug

class Reth
  include Ethereum

  Services = [
    App::DBService,
    App::AccountService,
    DEVp2p::Discovery::Service,
    DEVp2p::PeerManager,
    App::ChainService
  ].freeze

  attr :app, :config

  def initialize
    load_config

    Celluloid.boot
    @app = App::Full.new(@config)
  end

  def load_config
    profile = App::Profile[:livenet] # default to livenet profile

    App::Config.setup
    @config = profile.deep_merge App::Config.load

    genesis_from_config_file = @config.fetch(:eth, {})[:genesis]
    if genesis_from_config_file
      # Fixed genesis_hash take from profile must be deleted as custom genesis loaded
      @config[:eth].delete :genesis_hash
      @config[:eth][:genesis] = genesis_from_config_file
    end

    update_config_from_genesis_json @config[:eth][:genesis]

    # TODO: bootstrap_nodes_from_config_file

    dump_config
  end

  def dump_config
    puts_header 'CONFIGURATION'

    cfg = @config.to_hash
    alloc = cfg.fetch('eth', {}).fetch('block', {}).fetch('genesis_initial_alloc', {})
    if alloc.size > 100
      puts "omitting reporting of #{alloc.size} accounts in genesis"
      cfg['eth']['block'].delete('genesis_initial_alloc')
    end

    puts cfg
  end

  def register_services
    if Services.include?(App::AccountService)
      App::AccountService.register_with_app app
      # TODO: unlock_accounts
      begin
        app.services.accounts.coinbase
      rescue Ethereum::ValueError => e
        logger.fatal 'invalid coinbase', coinbase: (config.pow || {})[:coinbase_hex]
        exit 1
      end
    end

    exclude_services = @app.config[:deactivated_services] + [App::AccountService.name]
    Services.each do |service|
      raise ArgumentError, 'service must be BaseService' unless service.instance_of?(Class) && service < DEVp2p::BaseService

      next if exclude_services.include?(service.name)
      service.register_with_app @app
    end
  end

  def start
    register_services

    puts_header "starting"
    @app.start

    #trap("INT")  { @app.stop }
    #trap("TERM") { @app.stop }
    #trap("QUIT") { @app.stop }

    #10000.times do |i|
    #  sleep 2
    #  @app.services.db.put i.to_s, Time.now.to_s
    #  @app.services.db.commit
    #end

    @app.join
  end

  private

  def puts_header(text)
    puts "\n>>>>> #{text}"
  end

  def update_config_from_genesis_json(genesis_json_filename_or_hash)
    genesis = genesis_json_filename_or_hash.instance_of?(String) ?
      JSON.parse(File.read(genesis_json_filename_or_hash)) :
      genesis_json_filename_or_hash

    @config[:eth] ||= {}
    @config[:eth][:block] ||= {}

    id = ->(x) { x }
    parse_int_or_hex = ->(x) { Utils.parse_int_or_hex(x) }
    dec = ->(x) { Utils.decode_hex Utils.remove_0x_head(x) }

    m = {
      'alloc' => [:genesis_initial_alloc, id],
      'difficulty' => [:genesis_difficulty, parse_int_or_hex],
      'timestamp' => [:genesis_timestamp, parse_int_or_hex],
      'extraData' => [:genesis_extra_data, dec],
      'gasLimit' => [:genesis_gas_limit, parse_int_or_hex],
      'mixhash' => [:genesis_mixhash, dec],
      'parentHash' => [:genesis_prevhash, dec],
      'coinbase' => [:genesis_coinbase, dec],
      'nonce' => [:genesis_nonce, dec]
    }

    genesis.each do |k, v|
      target_key, trans = m[k]
      @config[:eth][:block][target_key] = trans.call v
    end
  end
end

Reth.new.start

